#!/usr/bin/env python3
"""
Database Model Tests - Comprehensive Test Suite

This file contains thorough tests for all database models.
We'll write tests FIRST, then implement models to pass these tests.

Test Categories:
1. Model Creation & Validation
2. Relationships & Foreign Keys
3. Database Constraints
4. Business Logic Methods
5. Edge Cases & Error Handling
"""

import pytest
import sys
import os
from datetime import datetime, timezone
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session

# Add app to path
sys.path.append(os.path.join(os.path.dirname(__file__), "app"))

from app.core.database import get_db, create_tables, drop_tables, Base, engine
from app.models.user import User

# We'll import these as we create them
from app.models.conversation import Conversation
# from app.models.message import Message
# from app.models.post import Post
# from app.models.comment import Comment


class TestDatabaseSetup:
    """Test database setup and basic operations."""
    
    def test_database_connection(self):
        """Test that we can connect to the database."""
        db = next(get_db())
        assert db is not None
        db.close()
    
    def test_create_drop_tables(self):
        """Test table creation and deletion."""
        # This will be important for testing
        drop_tables()  # Clean slate
        create_tables()  # Create fresh tables
        
        # Verify tables exist by checking metadata
        assert len(Base.metadata.tables) > 0


class TestUserModel:
    """Comprehensive tests for User model."""
    
    @pytest.fixture
    def db_session(self):
        """Create a fresh database session for each test."""
        drop_tables()
        create_tables()
        db = next(get_db())
        yield db
        db.close()
        drop_tables()
    
    def test_user_creation_basic(self, db_session):
        """Test basic user creation with minimal fields."""
        user = User(
            user_name="test_user",
            email="test@example.com"
        )
        
        db_session.add(user)
        db_session.commit()
        
        # Verify user was created
        assert user.user_id is not None
        assert user.user_name == "test_user"
        assert user.email == "test@example.com"
        assert user.is_private is False  # Default value
        assert user.status == "active"  # Default value
        assert user.created_at is not None
        assert user.updated_at is not None
    
    def test_user_creation_complete(self, db_session):
        """Test user creation with all fields."""
        user = User(
            user_name="complete_user",
            email="complete@example.com",
            phone="+1234567890",
            profile_picture="https://example.com/pic.jpg",
            gender="prefer_not_to_say",
            google_id="google_123",
            is_private=True
        )
        
        db_session.add(user)
        db_session.commit()
        
        # Verify all fields
        assert user.user_name == "complete_user"
        assert user.email == "complete@example.com"
        assert user.phone == "+1234567890"
        assert user.profile_picture == "https://example.com/pic.jpg"
        assert user.gender == "prefer_not_to_say"
        assert user.google_id == "google_123"
        assert user.is_private is True
    
    def test_user_unique_constraints(self, db_session):
        """Test that unique constraints work properly."""
        # Create first user
        user1 = User(user_name="unique_test", email="unique@test.com")
        db_session.add(user1)
        db_session.commit()
        
        # Try to create user with same username
        user2 = User(user_name="unique_test", email="different@test.com")
        db_session.add(user2)
        
        with pytest.raises(IntegrityError):
            db_session.commit()
        
        db_session.rollback()
        
        # Try to create user with same email
        user3 = User(user_name="different_name", email="unique@test.com")
        db_session.add(user3)
        
        with pytest.raises(IntegrityError):
            db_session.commit()
    
    def test_user_helper_methods(self, db_session):
        """Test user helper methods."""
        user = User(
            user_name="helper_test",
            profile_picture="https://example.com/pic.jpg"
        )
        db_session.add(user)
        db_session.commit()
        
        # Test helper methods
        assert user.is_active is True
        assert user.get_display_name() == "helper_test"
        assert user.has_profile_picture() is True
        
        # Test with no profile picture
        user.profile_picture = None
        assert user.has_profile_picture() is False
        
        # Test with empty profile picture
        user.profile_picture = "   "
        assert user.has_profile_picture() is False
    
    def test_user_status_inactive(self, db_session):
        """Test user with inactive status."""
        user = User(
            user_name="inactive_user",
            status="archived"
        )
        db_session.add(user)
        db_session.commit()
        
        assert user.is_active is False
    
    def test_user_string_representations(self, db_session):
        """Test __str__ and __repr__ methods."""
        user = User(user_name="string_test")
        db_session.add(user)
        db_session.commit()
        
        # Test string representations
        assert str(user) == "string_test"
        assert repr(user) == f"<User(id={user.user_id}, username=string_test)>"


class TestConversationModel:
    """Comprehensive tests for Conversation model."""
    
    @pytest.fixture
    def db_session(self):
        """Create a fresh database session for each test."""
        drop_tables()
        create_tables()
        db = next(get_db())
        yield db
        db.close()
        drop_tables()
    
    @pytest.fixture
    def sample_user(self, db_session):
        """Create a sample user for conversation tests."""
        user = User(
            user_name="conversation_user",
            email="conv@example.com"
        )
        db_session.add(user)
        db_session.commit()
        return user
    
    def test_conversation_creation_basic(self, db_session, sample_user):
        """Test basic conversation creation with minimal fields."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="Test Conversation"
        )
        
        db_session.add(conversation)
        db_session.commit()
        
        # Verify conversation was created
        assert conversation.conversation_id is not None
        assert conversation.user_id == sample_user.user_id
        assert conversation.title == "Test Conversation"
        assert conversation.forked_from is None  # Not forked
        assert conversation.status == "active"  # Default value
        assert conversation.created_at is not None
        assert conversation.updated_at is not None
    
    def test_conversation_creation_complete(self, db_session, sample_user):
        """Test conversation creation with all fields."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="Complete Conversation",
            forked_from=None,  # Will test forking separately
            status="active"
        )
        
        db_session.add(conversation)
        db_session.commit()
        
        # Verify all fields
        assert conversation.user_id == sample_user.user_id
        assert conversation.title == "Complete Conversation"
        assert conversation.forked_from is None
        assert conversation.status == "active"
    
    def test_conversation_user_relationship(self, db_session, sample_user):
        """Test conversation belongs to user (foreign key relationship)."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="Relationship Test"
        )
        
        db_session.add(conversation)
        db_session.commit()
        
        # Test foreign key relationship
        assert conversation.user_id == sample_user.user_id
        
        # Test SQLAlchemy relationship (when we add it)
        # assert conversation.user == sample_user
    
    def test_conversation_without_user_fails(self, db_session):
        """Test that conversation requires a valid user_id."""
        import uuid
        fake_user_id = uuid.uuid4()
        
        conversation = Conversation(
            user_id=fake_user_id,
            title="Invalid User Test"
        )
        
        db_session.add(conversation)
        
        # Should fail due to foreign key constraint
        with pytest.raises(IntegrityError):
            db_session.commit()
    
    def test_conversation_title_required(self, db_session, sample_user):
        """Test that conversation title is required."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title=None  # Should fail
        )
        
        db_session.add(conversation)
        
        with pytest.raises(IntegrityError):
            db_session.commit()
    
    def test_conversation_helper_methods(self, db_session, sample_user):
        """Test conversation helper methods."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="Helper Test"
        )
        db_session.add(conversation)
        db_session.commit()
        
        # Test helper methods
        assert conversation.is_active is True
        assert conversation.is_forked is False
        assert conversation.get_display_title() == "Helper Test"
        
        # Test with archived status
        conversation.status = "archived"
        assert conversation.is_active is False
    
    def test_conversation_forked_relationship(self, db_session, sample_user):
        """Test conversation can be forked from a post."""
        # This test will be enhanced when we have Post model
        # For now, test the forked_from field accepts UUID
        import uuid
        fake_post_id = uuid.uuid4()
        
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="Forked Conversation",
            forked_from=fake_post_id
        )
        
        db_session.add(conversation)
        db_session.commit()
        
        # Verify forked_from is stored correctly
        assert conversation.forked_from == fake_post_id
        assert conversation.is_forked is True
    
    def test_conversation_string_representations(self, db_session, sample_user):
        """Test __str__ and __repr__ methods."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="String Test"
        )
        db_session.add(conversation)
        db_session.commit()
        
        # Test string representations
        assert str(conversation) == "String Test"
        assert repr(conversation) == f"<Conversation(id={conversation.conversation_id}, title=String Test)>"
    
    def test_conversation_timestamps(self, db_session, sample_user):
        """Test that timestamps are set correctly."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="Timestamp Test"
        )
        
        # Store creation time in UTC to match database (with small buffer)
        before_creation = datetime.now(timezone.utc)
        
        db_session.add(conversation)
        db_session.commit()
        
        after_creation = datetime.now(timezone.utc)
        
        # Verify timestamps are set and reasonable (allow for small timing differences)
        assert conversation.created_at is not None
        assert conversation.updated_at is not None
        # Allow for database timestamps to be slightly before our Python timestamp
        assert conversation.created_at <= after_creation
        assert conversation.updated_at <= after_creation
        assert abs((conversation.created_at - before_creation).total_seconds()) < 5  # Within 5 seconds
        
        # Test updated_at changes on update
        original_updated_at = conversation.updated_at
        conversation.title = "Updated Title"
        db_session.commit()
        
        # updated_at should have changed
        assert conversation.updated_at > original_updated_at
    
    def test_conversation_status_validation(self, db_session, sample_user):
        """Test conversation status field validation."""
        # Test valid statuses
        valid_statuses = ["active", "archived", "deleted"]
        
        for status in valid_statuses:
            conversation = Conversation(
                user_id=sample_user.user_id,
                title=f"Status Test {status}",
                status=status
            )
            db_session.add(conversation)
            db_session.commit()
            
            assert conversation.status == status
            db_session.delete(conversation)
            db_session.commit()
    
    def test_multiple_conversations_per_user(self, db_session, sample_user):
        """Test that a user can have multiple conversations."""
        conversations = []
        
        for i in range(3):
            conv = Conversation(
                user_id=sample_user.user_id,
                title=f"Conversation {i+1}"
            )
            conversations.append(conv)
            db_session.add(conv)
        
        db_session.commit()
        
        # Verify all conversations were created
        for conv in conversations:
            assert conv.conversation_id is not None
            assert conv.user_id == sample_user.user_id
        
        # Verify they are distinct
        conversation_ids = [conv.conversation_id for conv in conversations]
        assert len(set(conversation_ids)) == 3  # All unique
    
    def test_conversation_cascade_behavior(self, db_session, sample_user):
        """Test what happens when user is deleted (cascade behavior)."""
        conversation = Conversation(
            user_id=sample_user.user_id,
            title="Cascade Test"
        )
        
        db_session.add(conversation)
        db_session.commit()
        
        conversation_id = conversation.conversation_id
        
        # Delete the user
        db_session.delete(sample_user)
        
        # This should fail due to foreign key constraint
        # (We don't want cascade delete for conversations)
        with pytest.raises(IntegrityError):
            db_session.commit()


class TestMessageModel:
    """Tests for Message model (to be implemented)."""
    
    def test_message_creation(self):
        """Test basic message creation."""
        # TODO: Implement when Message model is created
        pass
    
    def test_message_conversation_relationship(self):
        """Test message belongs to conversation."""
        # TODO: Test foreign key relationship
        pass
    
    def test_message_user_relationship(self):
        """Test message belongs to user (can be null for AI)."""
        # TODO: Test nullable user relationship
        pass
    
    def test_message_role_validation(self):
        """Test message role is valid (user, assistant, system)."""
        # TODO: Test role validation
        pass


class TestPostModel:
    """Tests for Post model (to be implemented)."""
    
    def test_post_creation(self):
        """Test basic post creation."""
        # TODO: Implement when Post model is created
        pass
    
    def test_post_user_relationship(self):
        """Test post belongs to user."""
        # TODO: Test foreign key relationship
        pass
    
    def test_post_conversation_relationship(self):
        """Test post belongs to conversation."""
        # TODO: Test foreign key relationship
        pass


class TestCommentModel:
    """Tests for Comment model (to be implemented)."""
    
    def test_comment_creation(self):
        """Test basic comment creation."""
        # TODO: Implement when Comment model is created
        pass
    
    def test_comment_post_relationship(self):
        """Test comment belongs to post."""
        # TODO: Test foreign key relationship
        pass
    
    def test_comment_user_relationship(self):
        """Test comment belongs to user."""
        # TODO: Test foreign key relationship
        pass
    
    def test_comment_parent_relationship(self):
        """Test comment can have parent comment (nested comments)."""
        # TODO: Test self-referential relationship
        pass


class TestModelRelationships:
    """Test complex relationships between models."""
    
    def test_user_conversations_relationship(self):
        """Test user can have multiple conversations."""
        # TODO: Test one-to-many relationship
        pass
    
    def test_conversation_messages_relationship(self):
        """Test conversation can have multiple messages."""
        # TODO: Test one-to-many relationship
        pass
    
    def test_post_comments_relationship(self):
        """Test post can have multiple comments."""
        # TODO: Test one-to-many relationship
        pass
    
    def test_cascade_deletions(self):
        """Test that deleting parent deletes children appropriately."""
        # TODO: Test cascade behavior
        pass


class TestBusinessLogic:
    """Test business logic and complex scenarios."""
    
    def test_conversation_forking_logic(self):
        """Test creating conversation forked from post."""
        # TODO: Test forking logic
        pass
    
    def test_post_privacy_logic(self):
        """Test post visibility based on user privacy settings."""
        # TODO: Test privacy logic
        pass
    
    def test_comment_threading_logic(self):
        """Test nested comment functionality."""
        # TODO: Test comment threading
        pass


# Test runner configuration
if __name__ == "__main__":
    # Run only User tests for now
    pytest.main([__file__ + "::TestUserModel", "-v"])
